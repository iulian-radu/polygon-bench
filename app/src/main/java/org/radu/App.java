/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.radu;

import io.polygon.kotlin.sdk.rest.PolygonRestApiCallback;
import io.polygon.kotlin.sdk.rest.PolygonRestClient;
import io.polygon.kotlin.sdk.rest.reference.SupportedTickersParametersBuilder;
import io.polygon.kotlin.sdk.rest.reference.TickersDTO;
import okhttp3.*;
import org.immutables.value.Value;
import org.jetbrains.annotations.NotNull;

import java.io.IOException;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;
import java.util.stream.Collectors;

@Value.Immutable
abstract class BenchmarkParameters {
    abstract int getPage();
    abstract int getTickersPerPage();
    abstract Long getTimestamp();
    abstract Semaphore getParallelismEnforcer();
    abstract CountDownLatch getLatch();
    abstract AtomicInteger getErrorCounter();
    abstract Collection<Long> getExecTimes();
}

@Value.Immutable
abstract class ResponseTimeInfo {
    abstract double getMean();
    abstract double getMedian();
    abstract double getStandardDeviation();
}

public class App {
    private static int MAX_PAGE = 600;
    private static String key = System.getenv("POLYGON_API_KEY");

    public static void main(String[] args) throws InterruptedException, IOException {
        var defaultClient = new PolygonRestClient(key);
        var apacheClient = new PolygonRestClient(key, new CustomApacheProvider());
        var cioClient = new PolygonRestClient(key, new CustomCIOProvider());
        var okHttpClient = new PolygonRestClient(key, new OkHttpProvider());


        var dispatcher = new Dispatcher();
        dispatcher.setMaxRequests(1000);
        dispatcher.setMaxRequestsPerHost(1000);
        var rawOkHttpClient = new OkHttpClient.Builder()
                .dispatcher(dispatcher)
                .retryOnConnectionFailure(true)
                .connectTimeout(20L, TimeUnit.SECONDS)
                .writeTimeout(20L, TimeUnit.SECONDS)
                .readTimeout(20L, TimeUnit.SECONDS)
                .protocols(Arrays.asList(Protocol.HTTP_1_1))
                .build();

        ExecutorService executor = Executors.newFixedThreadPool(1000);

        int numFetches = 1000;
        List<Integer> parallelism = Arrays.asList(
//                500
                100
//                10,
//                1
        );

        for (Integer par : parallelism) {

            // Custom implementation that calls OkHttp directly using its async dispatch. Does NOT use ktor
            benchmark("Raw OkHttp async - par: " + par,
                    (params) -> getPageWithRawOkHttpAsync(rawOkHttpClient, params), numFetches, par);

            // custom implementation that calls OkHttp directly in a blocking fashion. Uses threads for parallelism. Does NOT use ktor
            benchmark("Raw OkHttp blocking - par: " + par,
                    (params) -> getPageWithRawOkHttpBlocking(rawOkHttpClient, params, executor), numFetches, par);

            // Default client using async dispatch.
//            benchmark("Default client async - par: " + par,
//                    (params) -> getPageWithPolygonRestClientAsync(defaultClient, params), numFetches, par);
            // Default client using blocking functions and threads for parallelism.
//            benchmark("Default client blocking - par: " + par,
//                    (params) -> getPageWithPolygonRestClientBlocking(defaultClient, params, executor), numFetches, par);
            // Apache cient using async dispatch.
            benchmark("Apache client - 1000 threads (async) - par: " + par,
                    (params) -> getPageWithPolygonRestClientAsync(apacheClient, params), numFetches, par);
            // Apache client using blocking functions and threads for parallelism.
            benchmark("Apache client - 1000 threads (blocking) - par: " + par,
                    (params) -> getPageWithPolygonRestClientBlocking(apacheClient, params, executor), numFetches, par);
            benchmark("CIO client - 1000 threads (async) - par: " + par,
                    (params) -> getPageWithPolygonRestClientAsync(cioClient, params), numFetches, par);
            benchmark("CIO client - 1000 threads (blocking) - par: " + par,
                    (params) -> getPageWithPolygonRestClientBlocking(cioClient, params, executor), numFetches, par);
            benchmark("OkHttp client - 1000 threads (async) - par: " + par,
                    (params) -> getPageWithPolygonRestClientAsync(okHttpClient, params), numFetches, par);
            benchmark("OkHttp client - 1000 threads (blocking) - par: " + par,
                    (params) -> getPageWithPolygonRestClientBlocking(okHttpClient, params, executor), numFetches, par);
        }
        executor.shutdown();
    }

    private static PolygonRestApiCallback<TickersDTO> getPolygonCallback(BenchmarkParameters parameters) {
        return new PolygonRestApiCallback<TickersDTO>() {
            public void onError(Throwable throwable) {
                computeDuration();
                parameters.getLatch().countDown();
                parameters.getErrorCounter().incrementAndGet();
                parameters.getParallelismEnforcer().release();
            }

            public long computeDuration() {
                var end = System.currentTimeMillis();
                var time = end - parameters.getTimestamp();
                parameters.getExecTimes().add(time);
                return time;
            }

            public void onSuccess(TickersDTO t) {
                computeDuration();
                parameters.getLatch().countDown();
                parameters.getParallelismEnforcer().release();
            }
        };
    }

    private static void getPageWithPolygonRestClientAsync(PolygonRestClient client, BenchmarkParameters parameters) {
        try {
            parameters.getParallelismEnforcer().acquire();
            var params = new SupportedTickersParametersBuilder().tickersPerPage(parameters.getTickersPerPage()).page(parameters.getPage() % MAX_PAGE + 1).build();
            client.getReferenceClient().getSupportedTickers(params, getPolygonCallback(ImmutableBenchmarkParameters.copyOf(parameters).withTimestamp(System.currentTimeMillis())));
        } catch (InterruptedException ex) {
            parameters.getErrorCounter().incrementAndGet();
        }
    }

    private static void getPageWithPolygonRestClientBlocking(PolygonRestClient client, BenchmarkParameters parameters, ExecutorService executor) {
        try {
            parameters.getParallelismEnforcer().acquire();
            var start = System.currentTimeMillis();
            var params = new SupportedTickersParametersBuilder().tickersPerPage(parameters.getTickersPerPage()).page(parameters.getPage() % MAX_PAGE + 1).build();
            executor.execute(() -> {
                try {
                    client.getReferenceClient().getSupportedTickersBlocking(params);
                    var end = System.currentTimeMillis();
                    var time = end - start;
                    parameters.getExecTimes().add(time);
                } finally {
                    parameters.getLatch().countDown();
                    parameters.getParallelismEnforcer().release();
                }
            });
       } catch (Exception ex) {
            parameters.getErrorCounter().incrementAndGet();
       }
    }

    private static Callback getOkHttpCallback(BenchmarkParameters parameters) {
        return new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                response.close();
                computeDuration();
                parameters.getLatch().countDown();
                parameters.getParallelismEnforcer().release();
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                System.out.println(e);
                computeDuration();
                parameters.getLatch().countDown();
                parameters.getErrorCounter().incrementAndGet();
                parameters.getParallelismEnforcer().release();
            }

            public long computeDuration() {
                var end = System.currentTimeMillis();
                var time = end - parameters.getTimestamp();
                parameters.getExecTimes().add(time);
                return time;
            }
        };
    }

    private static void getPageWithRawOkHttpAsync(OkHttpClient client, BenchmarkParameters parameters) {
        try {
            parameters.getParallelismEnforcer().acquire();
            var params = new SupportedTickersParametersBuilder().tickersPerPage(parameters.getTickersPerPage()).page(parameters.getPage() % MAX_PAGE + 1).build();
            client.newCall(getRequestForPage(parameters.getPage() % MAX_PAGE + 1, key)).enqueue(getOkHttpCallback(
                    ImmutableBenchmarkParameters.copyOf(parameters).withTimestamp(System.currentTimeMillis())
            ));
        } catch (InterruptedException ex) {
            parameters.getErrorCounter().incrementAndGet();
        }
    }

    private static void getPageWithRawOkHttpBlocking(OkHttpClient client, BenchmarkParameters parameters, ExecutorService executor) {
        try {
            parameters.getParallelismEnforcer().acquire();
            var start = System.currentTimeMillis();
            executor.execute(() -> {
                try {
                    try(Response response = client.newCall(getRequestForPage(parameters.getPage() % MAX_PAGE + 1, key)).execute()) {
                        var end = System.currentTimeMillis();
                        var time = end - start;
                        parameters.getExecTimes().add(time);
                    }
                } catch (Exception e) {
                    parameters.getErrorCounter().incrementAndGet();
                } finally {
                    parameters.getLatch().countDown();
                    parameters.getParallelismEnforcer().release();
                }
            });
        } catch (Exception ex) {
            parameters.getErrorCounter().incrementAndGet();
        }
    }

    private static void benchmark(String clientDescription, Consumer<BenchmarkParameters> apiCaller,
                                  int numFetches, int parallelism) throws InterruptedException {
        var latch = new CountDownLatch(numFetches);
        AtomicInteger errorCounter = new AtomicInteger(0);
        Semaphore parallismEnforcer = new Semaphore(parallelism);
        List<Long> execTimes = Collections.synchronizedList(new LinkedList<>());
        var startTime = System.nanoTime();
        BenchmarkParameters parameters = ImmutableBenchmarkParameters.builder()
                .page(1)
                .tickersPerPage(200)
                .errorCounter(errorCounter)
                .latch(latch)
                .parallelismEnforcer(parallismEnforcer)
                .timestamp(System.currentTimeMillis())
                .execTimes(execTimes)
                .build();
        for (int i = 0; i < numFetches; ++i) {
            apiCaller.accept(ImmutableBenchmarkParameters
                            .copyOf(parameters)
                            .withPage(i)
                            .withTimestamp(System.currentTimeMillis()));
        }
        latch.await();
        var endTime = System.nanoTime();
        double timeInMs = (endTime - startTime) / 1000000.0;
        System.out.println(clientDescription + " took " + timeInMs + " ms. " + (numFetches * 1000.0 / timeInMs) + " fetches / second");
        ResponseTimeInfo histogram = computeHistogram(execTimes);
        System.out.println("Mean: " + histogram.getMean() + " median: " + histogram.getMedian() + " std dev: " + histogram.getStandardDeviation());
        System.out.println("Errors: " + errorCounter.get());
    }

    private static ResponseTimeInfo computeHistogram(Collection<Long> execTimes) {
        Collection<Double> timesInSeconds = execTimes.stream().map(t -> t / 1000.0).collect(Collectors.toList());
        Double median = timesInSeconds.stream().sorted().collect(Collectors.toList()).get(timesInSeconds.size() / 2);
        Double mean = timesInSeconds.stream().reduce(0.0, Double::sum) / timesInSeconds.size();
        Double stdDev = Math.sqrt(timesInSeconds.stream().map(t -> (t - mean) * (t - mean)).reduce(0.0, Double::sum) / timesInSeconds.size());
        return ImmutableResponseTimeInfo.builder()
                .mean(mean)
                .median(median)
                .standardDeviation(stdDev)
                .build();
    }

    private static Request getRequestForPage(int page, String key) {
        return new okhttp3.Request.Builder()
                .url("https://api.polygon.io/v2/reference/tickers?perpage=200&page=" + page + "&apiKey=" + key)
                .build();
    }
}
